import umbridge
import numpy as np
import cuqi
from heat1D_problem import create_forward_PDE_model, obs_everywhere_indices, obs_left_half_indices, dim, N, sigma, large_noise_level, small_noise_level, prior_mean, prior_cov


class Heat1D_UM(umbridge.Model):
    """Base benchmark for all the heat 1D problems"""

    def __init__(self, name, noise_level, obs_indices, data, y_exact):
        """Initialize the model

        parameters
        ----------
        name : str
            The name of the model

        noise_level : float
            The relative noise level of the data
        
        obs_indices : list
            The grid indices at which we have observations

        data : np.ndarray
            The observed noisy data to be used for the inversion
        """
        # Create the forward model
        model = create_forward_PDE_model(obs_indices)
        domain_geometry = model.domain_geometry
        range_geometry = model.range_geometry

        # Create the prior distribution
        x = cuqi.distribution.Gaussian(mean=prior_mean, cov=prior_cov,
                                       geometry=domain_geometry)

        # Create the data distribution
        y = cuqi.distribution.Gaussian(model(x),
            sigma(noise_level, y_exact)**2*np.eye(model.range_dim),
            geometry=range_geometry)
               
        # Bayesian model
        joint_distribution = cuqi.distribution.JointDistribution(x, y)
        self.posterior = joint_distribution(y = data) 
        super().__init__(name)

    def get_input_sizes(self, config):
        return [dim]

    def get_output_sizes(self, config):
        return [1]

    def __call__(self, parameters, config):
        output = self.posterior.logpdf(np.asarray(parameters[0]))
        return [[output[0]]]

    def supports_evaluate(self):
        return True

    def supports_gradient(self):
        return False


class Heat1DSmallNoise(Heat1D_UM):
    """Heat 1D benchmark with small noise level"""

    def __init__(self):
        # Load noisy and exact data.
        # These were originally generated by the data_script.py script.
        data_dict = np.load("data_small_noise.npz")
        data = data_dict["data"]
        y_exact = data_dict["y_exact"]
        noise_level = small_noise_level
        obs_indices = obs_everywhere_indices
        super().__init__(self.__class__.__name__,
                         noise_level=noise_level,
                         obs_indices=obs_indices,
                         data=data,
                         y_exact=y_exact)


class Heat1DLargeNoise(Heat1D_UM):
    """Heat 1D benchmark with large noise level and data available only
       at the first half of the domain"""

    def __init__(self):
        # Load noisy and exact data.
        # These were originally generated by the data_script.py script.
        data_dict = np.load("data_large_noise.npz")
        data = data_dict["data"]
        y_exact = data_dict["y_exact"]
        noise_level = large_noise_level
        obs_indices = obs_left_half_indices
        super().__init__(self.__class__.__name__,
                         noise_level=noise_level,
                         obs_indices=obs_indices,
                         data=data,
                         y_exact=y_exact)


class Heat1DExactSolution(umbridge.Model):
    """Exact solution for the heat 1D benchmark"""

    def __init__(self):
        """Initialize the model. Load the exact solution from file."""
        data_dict = np.load("data_small_noise.npz")
        self.exactSolution = data_dict["x_exact"]
        super().__init__(self.__class__.__name__)

    def get_input_sizes(self, config):
        return [0]

    def get_output_sizes(self, config):
        return [len(self.exactSolution)]

    def __call__(self, parameters, config):
        return [self.exactSolution.tolist()]

    def supports_evaluate(self):
        return True
    

class KLExpansionCoefficient2Function(umbridge.Model):
    """Representation of a mapping from KL expansion coefficients to 
    function value."""

    def __init__(self):
        """Initialize the model. Load the exact solution from file."""
        self.KL_geometry =  create_forward_PDE_model(obs_everywhere_indices).domain_geometry
        super().__init__(self.__class__.__name__)

    def get_input_sizes(self, config):
        return [dim]

    def get_output_sizes(self, config):
        return [N]

    def __call__(self, parameters, config):
        return [self.KL_geometry.par2fun(np.array(parameters[0])).tolist()]

    def supports_evaluate(self):
        return True

class KLExpansionFunction2Coefficient(umbridge.Model):
    """Representation of mapping from function value to KL expansion 
    coefficients."""

    def __init__(self):
        """Initialize the model. Load the exact solution from file."""
        self.KL_geometry = create_forward_PDE_model(obs_everywhere_indices).domain_geometry
        super().__init__(self.__class__.__name__)

    def get_input_sizes(self, config):
        return [N]

    def get_output_sizes(self, config):
        return [dim]

    def __call__(self, parameters, config):
        return [self.KL_geometry.fun2par(np.array(parameters[0])).tolist()]

    def supports_evaluate(self):
        return True

model_large_noise = Heat1DLargeNoise()
model_small_noise = Heat1DSmallNoise()
model_exactSolution = Heat1DExactSolution()
kl_expansion_coefficient2function = KLExpansionCoefficient2Function()
kl_expansion_function2coefficient = KLExpansionFunction2Coefficient()


umbridge.serve_models(
    [model_large_noise,
     model_small_noise,
     model_exactSolution,
     kl_expansion_coefficient2function,
     kl_expansion_function2coefficient
     ], 4243
)
