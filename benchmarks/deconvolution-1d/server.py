import umbridge
import numpy as np
import cuqi


class Deconvolution1D_UM(umbridge.Model):
    """Base benchmark for all 1D deconvolution problems"""

    dim = 128  # Dimension of the 1D signal
    default_delta = 0.01  # Default value for delta

    def __init__(self, name):
        """Initialize the model

        parameters
        ----------
        name : str
            Name of the model

        """
        # Load data and exact phantom from file.
        # These were originally generated by the data_script.py script.
        data = np.load("data_square.npz")

        # Set up test problem
        TP = cuqi.testproblem.Deconvolution1D(
            dim=self.dim,
            PSF="gauss",
            PSF_param=5,
            phantom="square",
            noise_std=0.01,
            noise_type="gaussian",
        )

        # Set data code
        TP.likelihood.data = data["data"]

        self.likelihood = TP.likelihood
        self.prior = TP.prior

        super().__init__(name)

    def get_input_sizes(self, config):
        return [self.dim]

    def get_output_sizes(self, config):
        return [1]

    def __call__(self, parameters, config):
        posterior = self._configure_posterior(config)
        output = posterior.logpdf(np.asarray(parameters[0]))
        return [[output[0]]]

    def gradient(self, out_wrt, in_wrt, parameters, sens, config):
        posterior = self._configure_posterior(config)
        # Compute gradient of logpdf. Since logpdf is R^n -> R,
        # the gradient is a vector of length n.
        # In CUQIpy the gradient method returns the Jacobian action
        # parameters.T * J(sens), but since the Jacobian (in this case)
        # is independent of the sens they area not passed to the
        # gradient method.
        output = posterior.gradient(np.asarray(parameters[0])) * sens
        return output.tolist()

    def supports_evaluate(self):
        return True

    def supports_gradient(self):
        return True

    def _configure_posterior(self, config) -> cuqi.distribution.Posterior:
        """ Configure the posterior distribution by conditioning on the delta parameter. """
        if (not "delta" in config):
            config["delta"] = self.default_delta
        prior = self.prior(delta=config["delta"])
        posterior = cuqi.distribution.Posterior(self.likelihood, prior)
        return posterior


class Deconvolution1D_Gaussian(Deconvolution1D_UM):
    """Deconvolution 1D with Gaussian prior"""

    def __init__(self):
        super().__init__(self.__class__.__name__)
        self.prior = cuqi.distribution.Gaussian(np.zeros(self.dim), lambda delta: delta, name="x")


class Deconvolution1D_GMRF(Deconvolution1D_UM):
    """Deconvolution 1D with Gaussian Markov Random Field (GMRF) prior"""

    def __init__(self):
        super().__init__(self.__class__.__name__)
        self.prior = cuqi.distribution.GMRF(np.zeros(self.dim), lambda delta: 1 / delta, name="x")


class Deconvolution1D_LMRF(Deconvolution1D_UM):
    """Deconvolution 1D with Laplace Markov Random Field (LMRF) prior"""

    def __init__(self):
        super().__init__(self.__class__.__name__)
        self.prior = cuqi.distribution.Laplace_diff(np.zeros(self.dim), lambda delta: delta, name="x")

    def supports_gradient(self):
        return False


class Deconvolution1D_CMRF(Deconvolution1D_UM):
    """Deconvolution 1D with Cauchy Markov Random Field (CMRF) prior"""

    def __init__(self):
        super().__init__(self.__class__.__name__)
        self.prior = cuqi.distribution.Cauchy_diff(np.zeros(self.dim), lambda delta: delta, name="x")


class Deconvolution1D_ExactSolution(umbridge.Model):
    """Exact solution for the 1D deconvolution problem"""

    def __init__(self):
        """Initialize the model. Load the exact solution from file."""
        data = np.load("data_square.npz")
        self.exactSolution = data["exact"]
        super().__init__(self.__class__.__name__)

    def get_input_sizes(self, config):
        return [0]

    def get_output_sizes(self, config):
        return [len(self.exactSolution)]

    def __call__(self, parameters, config):
        return [self.exactSolution.tolist()]

    def supports_evaluate(self):
        return True


model_Gaussian = Deconvolution1D_Gaussian()
model_GMRF = Deconvolution1D_GMRF()
model_LMRF = Deconvolution1D_LMRF()
model_CMRF = Deconvolution1D_CMRF()
model_exactSolution = Deconvolution1D_ExactSolution()

umbridge.serve_models(
    [model_Gaussian, model_GMRF, model_LMRF, model_CMRF, model_exactSolution], 4243
)
